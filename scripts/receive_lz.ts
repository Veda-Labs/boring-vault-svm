import { Program } from "@coral-xyz/anchor";
import * as anchor from "@coral-xyz/anchor";
import {
  PublicKey,
  Transaction,
  ComputeBudgetProgram,
  AccountMeta,
} from "@solana/web3.js";
import BN from "bn.js";
import "dotenv/config";

import { LayerZeroShareMover } from "../target/types/layer_zero_share_mover";
import { initAnchor, hexBuf } from "./utils";

// ────────────────────────────────────────────────────────────────────────────
// Configuration – fill these from LayerZero Scan / external source
// ────────────────────────────────────────────────────────────────────────────
const SRC_EID = 30214;
const SENDER_BYTES32 =
  "0x000000000000000000000000c1caf4915849cd5fe21efaa4ae14e4eafa7a3431";
const NONCE = 8n;
const GUID_HEX =
  "0x2e3957a69d861f3f7840f8257b279e0cf36abc1f5e9de584e8385f13f7bd3258"; // 32-byte guid
const MESSAGE_HEX =
  "0xaa118f46fd933a74befe80395d1ddb2a094a77ca078de0070fe4e74af6c42821000000000000000000000000000f4240"; // payload bytes
const EXTRA_HEX = "0x"; // usually 0x

// Program IDs on Solana ------------------------------------------------------
const ENDPOINT_PID = new PublicKey(
  "76y77prsiCMvXMjuoZ5VRrhG5qYBrUMYTE5WgHqgjEn6"
);
const SHARE_MINT = new PublicKey(
  "88ZgQ7nKQeAHV7Q4ivAT7QaeabCzSpuKa8T8PNRaAm4e"
);
const SHARE_MOVER_PROGRAM = new PublicKey(
  "CU9XermEoiawu8eYwSyXBHgMESRwWEycDU9jjk9MHSgN"
);

// Toggle between simulation (dry-run) and sending the real transaction.
const SIMULATION = true;

// ---------------------------------------------------------------------------
async function main() {
  // Provider / wallet -------------------------------------------------------
  const { connection, payer, provider } = initAnchor();

  // Program client generated by Anchor (IDL pre-built)
  const smProgram =
    anchor.workspace.LayerZeroShareMover as Program<LayerZeroShareMover>;

  // Derive ShareMover PDA (needed for accounts list)
  const [shareMoverPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("share_mover"), SHARE_MINT.toBuffer()],
    SHARE_MOVER_PROGRAM
  );

  // -----------------------------------------------------------------------
  // Build lzReceiveTypes params & instruction (view/helper)
  // -----------------------------------------------------------------------
  const lzParams = {
    srcEid: SRC_EID,
    sender: Array.from(hexBuf(SENDER_BYTES32)),
    nonce: new BN(NONCE.toString()),
    guid: Array.from(hexBuf(GUID_HEX)),
    message: hexBuf(MESSAGE_HEX),
    extraData: hexBuf(EXTRA_HEX),
  } as const;

  // lzReceiveTypes returns account list via returnData ---------------------
  const typesIx = await smProgram.methods
    .lzReceiveTypes(lzParams)
    .accounts({ store: shareMoverPda })
    .instruction();

  // Simulate to obtain remaining accounts encoded in return data -----------
  const simTypes = await provider.connection.simulateTransaction(
    new Transaction({ feePayer: payer.publicKey }).add(typesIx),
    [payer]
  );
  if (!simTypes.value?.returnData) {
    throw new Error("lzReceiveTypes simulation returned no data");
  }
  const rawRet = Buffer.from(simTypes.value.returnData.data[0], "base64");

  // Deserialize Vec<AccountMeta> (each entry = 32 + 1 + 1 bytes) -----------
  const vecLen = rawRet.readUInt32LE(0);
  const accounts: AccountMeta[] = [];
  let offset = 4;
  for (let i = 0; i < vecLen; i++) {
    const pubkey = new PublicKey(rawRet.slice(offset, offset + 32));
    const isSigner = rawRet[offset + 32] === 1;
    const isWritable = rawRet[offset + 33] === 1;
    accounts.push({ pubkey, isSigner, isWritable });
    offset += 34;
  }

  // -----------------------------------------------------------------------
  // Build the real lzReceive instruction
  // -----------------------------------------------------------------------
  const receiveIx = await smProgram.methods
    .lzReceive(lzParams)
    .accounts({
      shareMover: accounts[0].pubkey,
      peer: accounts[1].pubkey,
    })
    .remainingAccounts(accounts.slice(2))
    .instruction();

  const cuIx = ComputeBudgetProgram.setComputeUnitLimit({ units: 350_000 });
  const tx = new Transaction({ feePayer: payer.publicKey })
    .add(cuIx)
    .add(receiveIx);

  if (SIMULATION) {
    const sim = await provider.simulate(tx, [payer]);
    console.log("Simulation logs:", sim.logs);
    const raw = (sim as any).raw;
    if (raw?.value?.err) throw new Error(JSON.stringify(raw.value.err));
    console.log("✓ Simulation succeeded");
  } else {
    const sig = await provider.sendAndConfirm(tx, [payer]);
    console.log("✓ Transaction confirmed:", sig);
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});